                                YACUT v1.0 manual

This file describes the usage of the yacut C testing framework.
It is just a single ANSI C header, just include it and compile.
The macro YCT_VERSION_MAJOR() is and ALWAYS will be present. This is the
standard way to detect yaCut (and its version, see also YCT_VERSION_MINOR()).
It is heavily based on preprocessor macros, see examples to get started with
code. All macros start with YCT_. If your editor is smart enough just type
"YCT_" and it should offer you ALL available macros.
yaCut doesn't support some input parameter, but if compilation fails, or
output is not as expected, you can look at the macro YCT_FUNC_NAME.
Next section describes the macro you can define BEFORE including yaCut.
You can ignore them unless you have compilation errors.
Then follows a list of all available macros (excluding the *_MSG version).


------------------------------------------------------------------------------


SECTION: General


YCT_GET_NAME();
Returns a string literal representing the name of the library.

YCT_VERSION_MAJOR();
Returns an integer representing the major version of the library.
Present in ALL versions of yaCut, use this macro to detect yaCut presence.

YCT_VERSION_MINOR();
Returns an integer representing the minor version of the library.

YCT_SET_OUTPUT(handle);
Set the output handle. The default is stdout. You can pass your FILE* variable.
This macro is to be used in a main context. If you want to change the output
handle inside another context (test/suite), you have to access the internal
yaCut context (see how assertions write).
Handle must be already opened and writable. It won't be closed.

YCT_GET_DATA(context);
The current struct yct_context is copied to context. For advanced users.

YCT_GET_RETURN_VALUE(status);
Give a status number according to current context.
The integer variable status will be 0 if all ok, 1 if some warning, or 2 on
assertions failure. It is recommended to use YCT_STATUS_OK, YCT_STATUS_WARNING
and YCT_STATUS_FAILED macros instead of numbers.

YCT_DUMP_SHORT();
Print something like "all ok" or "some warning" or "some failure".

YCT_DUMP();
Print a quite detailed summary of execution. Typically used as last directive
before YCT_END.


-----------------------------------------------------------------------------


SECTION: Main


YCT_BEGIN(name);
Start a new context named name. It will be showed when YCT_DUMP is called.
If you pass a null or empty string to the macro, no name is written.
This macro is mandatory unless you use YCT_MAIN. Context must be closed by a
call to YCT_END macro. To be used inside a function.
Note that you can declare as many YCT_BEGIN/YCT_END contexts as you want,
even more than one inside the same function!


YCT_END();
Close the current test context started by YCT_BEGIN.

YCT_TEST(test) { ... }
Define a test. Put your assertions here (See assertions section).
No return value is allowed. To be used in global scope.

YCT_TEST_RUN(test);
Run the test test. To be used in YCT_BEGIN/YCT_END context.

YCT_MAIN(test_or_suite);
This macro defines a custom main so you must not write your own. The parameter
must be a defined test or suite to be run.
Note that a single entry test/suite is not a limit (see YCT_BEGIN notes).


-----------------------------------------------------------------------------


SECTION: Suites
Suites have a central role in xUnit architecture. A suite is just a collection
of tests that can share the same environment. This is done by setting two
functions in the YCT_SUITE macro. This will ensure (or better gives you the
opportunity) to execute all tests in the same environment (see xUnit
documentation). Note that f_setup/f_teardown may be useful at suite level too.
Almost all C and even C++ test framework do not support directly this feature.
And so does yaCut. Anyway you can easily have this just calling a user defined
function at the beginning of the suite and another at the end of the suite.
See code example ex_suite.c

YCT_SUITE(suite, f_setup, f_teardown) { ... }
Define the suite suite. f_setup and f_teardown are functions that take no
parameter and return void. If f_setup is not NULL, it is called BEFORE each
test added in the current suite. If f_teardown is not NULL, it is called AFTER
each test added in the current suite. Suite context must be closed with
the YCT_SUITE_END macro, no return value is allowed. To be used in global
scope.

YCT_SUITE_END
Close the suite opened by YCT_SUITE. Note that no parentheses and/or semicolon
follow. This macro must be put after the YCT_SUITE block.

YCT_TEST_ADD(test);
Add test test to current suite. To be used inside YCT_SUITE context.

YCT_SUITE_RUN(suite);
Run the suite suite. To be used inside YCT_BEGIN/YCT_END context.


-----------------------------------------------------------------------------


SECTION: Skip
This section explains available ways to skip tests/suites.
You will notice that you can skip a test/suite prepending "DISABLE_" to
tests/suite declarations, without touching anything inside YCT_BEGIN/YCT_END
context. On the other side, leaving standard declarations, you can prepend
"NO_" to YCT_TEST_ADD/YCT_TEST_RUN/YCT_SUITE_RUN inside YCT_BEGIN/YCT_END
or YCY_SUITE context. The 3rd way is to call YCT_DISABLE to skip all
following tests/suites and possibly restore standard behaviour by calling
YCT_ENABLE.
See code example ex_skip.c

DISABLE_YCT_TEST(test);
The defined test will not execute, when inside a suite or when explicitly
called by YCT_TEST_RUN macro.

DISABLE_YCT_SUITE(suite, f_setup, f_teardown);
The defined suite will not execute when called by YCT_SUITE_RUN macro.

NO_YCT_TEST_RUN(test)
The passed test will NOT execute. The test can be declared normally or
with the now redundant DISABLE_YCT_TEST macro. It is simply ignored.

NO_YCT_SUITE_RUN(suite);
The passed suite will NOT execute. The suite can be declared normally or
with the now redundant DISABLE_YCT_SUITE macro. It is simply ignored.

NO_YCT_TEST_ADD(test);
The passed test won't be added to current suite.

YCT_DISABLE();
All following warnings, assertions, tests and suites will NOT execute.
Use YCT_ENABLE to restore normal behaviour.
Note that YCT_MESSAGE is always available.

YCT_ENABLE();
Stop skipping warning, assertions, tests, suites. Restore normal behaviour.
Typical usage is after some disabled tests by a call to YCT_DISABLE.

YCT_IS_ENABLED();
Returns 1 if enabled (default), 0 if not (tests are not running).


-----------------------------------------------------------------------------


SECTION: Blocking mode
The blocking mode allows to set the behaviour to follow when a test fails.
The default mode is to execute all tests, even when some fails.
With YCT_SET_BLOCKED you can stop execution when an assertion fails.
With YCT_SET_FULL_BLOCKED execution stops when a warning is issued too.
The locking mode is isolated to current context (YCT_BEGIN/YCT_END block).
If you have multiple YCT_BEGIN/YCT_END blocks and one get locked, you have
to stop others manually. (if !YCT_IS_LOCKED() ...).
See code example ex_block.c

YCT_SET_BLOCKED();
Assertions failure will block the execution of all future tests and suites of
current context. Useful when you want to stop at the first failure.

YCT_SET_FULL_BLOCKED();
Same as YCT_SET_BLOCKED, but even warnings failure cause the context to lock.
You can tune the failure policy balancing warnings and assertions.

YCT_DISABLE_BLOCKING();
Restore original blocking behaviour: Tests are executed even if some previous
fail.
ATTENTION: This call has NO EFFECT if context is already locked!

YCT_IS_LOCKED();
Returns non-zero if the current context is locked (a failure occurred and some
blocking mode was set). Otherwise returns 0.


-----------------------------------------------------------------------------


SECTION: Assertions

Assertions are the basic entities to test software. In this section are listed
all assertions you can use. Except YCT_MESSAGE and YCT_FAIL that already have
it, all assertions have a second version that additionally write a custom
message. Just append '_MSG' to their original name and append the message as
last parameter. The message can be a string literal or a char*. UTF-8 strings
are accepted but wchar_t* strings or literals do not work. See YCT_ASSERT_MSG
below as example.
You will notice that most macros have the _NOT_ version to negate condition.
Assertions are typically used inside YCT_TEST block. However you can use them
inside a YCT_SUITE scope too. They can be even used in YCT_BEGIN context if it
resides inside a function that returns void. YCT_MESSAGE doesn't have this
limitation and can be used in any YCT context.

YCT_MESSAGE(message);
Write message on output stream.

YCT_WARNING(condition);
Issue a warning if condition is false.

YCT_FAIL(message);
Abort current test and writes message.

YCT_ASSERT(condition);
Abort current test if condition fails.

YCT_ASSERT_MSG(condition, message);
Abort current test and write message if condition fails.

YCT_ASSERT_EQUAL(a, b);
Abort current test if a != b. Do NOT use with strings/array/objects (structs).
Technically this assertion can be used with pointers since they are elementary
types, but keep in mind that this will compare pointers only, NOT the pointed
data! Since version 1.0.4, values will be converted to double, so some
incorrect reporting may be encountered (ex.: integers > 2^53)

YCT_ASSERT_NOT_EQUAL(a, b);
Abort current test if a == b. See notes above.

YCT_ASSERT_NULL(ptr);
Abort current test if ptr is not NULL.

YCT_ASSERT_NOT_NULL(ptr);
Abort current test if ptr is NULL.

YCT_ASSERT_EQUAL_STR(str1, str2);
Abort current test if string str1 and str2 are different.
char and wchar_t array/pointers are typically expected as arguments.

YCT_ASSERT_NOT_EQUAL_STR(str1, str2);
Abort current test if string str1 and str2 are equal.
char and wchar_t array/pointers and/or string literals are typically expected
as arguments.

YCT_ASSERT_EQUAL_ARRAY(a1, a2, len);
Abort current test if arrays a1 and a2 have a different element in range
[0, len].

YCT_ASSERT_NOT_EQUAL_ARRAY(str1, str2, len);
Abort current test if arrays a1 and a2 have all elements equal in range
[0, len].

YCT_ASSERT_EQUAL_OBJ(obj1, obj2, fcmp);
Abort current test if obj1 and obj2 are different. fcmp is the function used
to compare passed objects. The fcmp prototype must be:
int fcmp(const T* pObj1, const T* pObj2);
where T is the type of BOTH objects. fcmp must return 0 if equal.
Note that constant pointers are preferred, but just T* can be passed.

YCT_ASSERT_NOT_EQUAL_OBJ(obj1, obj2, fcmp);
Abort current test if obj1 and obj2 are equal. See notes above.

YCT_ASSERT_EQUAL_FLOAT(a, b, t);
Abort current test if abs(a - b) > t. Numbers a and b are considered equal if
their difference is less or equal than tolerance t.
Typical usage is with float and double, FLOATing point numbers generically.

YCT_ASSERT_NOT_EQUAL_FLOAT(a, b, t);
Abort current test if abs(a - b) <= t.


-----------------------------------------------------------------------------


Michele Pes -- mp81ss@rambler.ru
Happy testing!

P.S.:
This is dedicated to Paperotta
